PATULARU IOANA-IRINA
331CB
	Intreaga implementare a temei se bazeaza pe functia parse_command() astfel
ca la primirea unei comenzi in shell, dupa parsare, in main() se apeleaza aceasta
functie. Aici se face efectiv parcurgerea arborelui construit in prealabil la
parsare in preordine; se verifica mai intai ce comanda avem in acest "nod".
   Daca nu avem un opearator inseamna ca este o comanda simpla care se gaseste
evident intr-o frunza. Se apeleaza functia parse_simple() pentru a o executa. 
In parse_simple() ne ocupam mai intai de partea de redirectare a output-ului: 
verificam daca in comanda ni se specifica sa redirectam iesirea standard catre
un fisier anume, la fel si pentru iesirea de eroare standard. In acest caz 
deschidem fisierele specificate si redirectam STDOUT_FILENO si STDERR_FILENO 
catre ele. La fel procedam si pentru intrarea standard, verificam daca citirea
se face din fisier si redirectam STDIN_FILENO catre el. Dupa redirectari, 
vom verifica cateva cazuri particulare ce nu necesita execvp(): daca avem 
"exit" sau "quit" vom returna direct codul de iesire din shell predefinit, 
daca este "cd" vom apela shell_cd() unde vom schimba directorul de lucru si
vom returna un cod de succes daca nu au aparut probleme. Daca avem "true" sau
"false" vom returna exact valoarea specifica lor iar daca avem "=" este vorba
de o variabila de mediu, caz in care se preia valoarea ei si se apeleaza setenv().
Daca nu este niciuna din acestea continuam prin crearea unui proces copil: acesta
va apela get_argv() pentru a-si lua toti parametrii si va executa comanda. In 
cazul in care execv() returneaza -1 inseamna ca este vorba de o comanda
necunoscuta si se afiseza mesajul specific. Parintele va astepta copilul sa 
termine dupa care va verifica statusul executiei lui, daca a fost cu succes 
sau nu.
	Daca este operatorul secvential, se va apela recursiv parse_command()
pentru arborele din stanga apoi pentru cel din dreapta netinandu-se cont de
valoarea returnata de executia lor deoarece rularile sunt independente.
	Daca este operatorul paralel, se va apela functia do_in_parallel().
In aceasta am creat un proces copil caruia i-am dat sa ruleaze prima 
comanda si in paralel parintele sa o ruleaze pe a doua.
	Daca este operatorul conditional ||, vom apela parse_command() pentru
subarborele stang si vom retine rezultatul returnat. Daca se returneaza
ceva diferit de 0 (nu s-a executat cu succes) o vom rula si pe a doua si 
in functie de outputul ei vom stabili valoarea de return. Daca prima s-a
executat cu succes, nu mai are rost sa o rulam pe cea de-a doua.
	Daca este operatorul &&, vom apela parse_command() pentru subarborele
stang si vom retine rezultatul returnat. Daca s-a executat cu succes, vom 
apela si pentru subarborele drept si vom returna rezultatul potrivit operatiei.
Daca nici macar pentru subarborele stang nu s-a obtinut un rezultat de 
succes(0), nu vom mai executa ce este in partea dreapta a arborelui.
	Daca avem operatorul pipe, apelam functia do_on_pipe(). Aici vom face 
o copie a descriptorului de STDIN pentru a-l putea recupera la final si
a redirecta shellul. Aici cream mai intai un pipe anonim dupa care vom creea
cu fork() un proces copil. Copilul va fi cel care va executa prima comanda
(va apela parse_command() pentru subarborele stang) si va scrie rezultatul 
in pipe. Din acest motiv, mai intai se inchide capul de read ai pipe-ului
si se va redirecta descritprul de STDOUT catre capul de scriere al pipe-ului
si apoi se executa comanda. Parintele concomitent va incepe sa ia date din 
pipe pentru comanda sa(ce e in subarborele drept) dar mai intai va inchide
capul de scriere al pipe-ului si va redirecta STDIN-ul catre capul de citire
din pipe, apoi va apela parse_command(). La final, va astepta dupa copil sa
termine si va reface descriptorul de STDIN.